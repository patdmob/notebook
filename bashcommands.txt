Basic Bash Commands

CMD SEARCH/HELP
which	- searches for the location of a command (where on windows)
history	- prints a list of commands you've typed (stores 1000 unique commands)
whatis 	- displays a short description of a command
apropos - search the whatis database for strings
man 	- displays the on-line manual pages (outdated, use info)
info 	- designed to replace info

MOVING AROUND
ls     - list storage (-l list)(-a all) 
cd     - change directory
pushd  - saves current location in stack and cd to specified
popd   - cd to next value in pushd stack
locate - gives a list of paths for a given pattern

MAKING/MOVING/RENAMING/COPYING/OPEN/VIEW - FILES/DIRECTORIES
mkdir - make directories 
rmdir - remove empty directories
touch - creates an empty file or changes access and modification times
cp    - copy file 
mv    - move or rename a file
rm    - remove files and directories (-r recursive) (-f force)
echo  - displays a line of text either on standard output or to place in a file
head  - displays the first few lines of a file or stout
tail  - displays the last few lines of a file or stdout 
cat   - concatenate and print files
open  - opens the file (. for folder)
less  - used to view files instead of opening the file ('q' quit)('space' page down)
nano  - basic text editor 


Intermediate Bash Commands

FILE MANIPULATION UTILITIES
sed   - popular stream editor used to filter/substitute text in files and data streams
awk   - typically used as a data extraction and reporting tool
sort  - sorts lines (-r for descending) (-k 3 by third field) (-u returns uniq values after sort)
uniq  - removes duplicate lines from text (requires consecutive duplicates) (-c for count)
paste - merge lines/columns of a file(s) using -d delimiters
join  - merge two files with similar columns without repeating the data
split - breaks a file into 1000 line segments
cut   - extract specific columns from column-based files 

TEXT SEARCH/MANIPULATION
grep    - print lines matching pattern (-v not match)(-C context above and below)
strings - extracts all printable content from an argument file list
tr      - text utility (translate) 
wc 	- word count displays lines, words, and characters (-l lines) (-c bytes) (-w words)

USER RELATED CMDS
sudo        - enter command as root
sudo -s     - change to root account (recommended over su)
su <user>   - change to <user> account
su - <user> - change to <user> account and navigate to their home directory
users 	    - shows active users
id	    - gives all pertinent information about user account
whoami	    - returns the current user


PIPELINES
|    - pipe the standard output of one command into another command's standard input
|&   - the stderr and stdout of cmd1 are connected to cmd2 stdin; shorthand for 2>&1 |


NETWORKING RELATED CMDS
arp       - 
whois     - 
dig 	  - dig	Tests DNS workings. A good replacement for host and nslookup.
ipconfig  - newer utility of ifconfig, may not be installed by default 
ifconfig  - 
ping      -  
netstat   - Displays all active connections and routing tables

TRANSFERING FILES:
ssh	- secure shell
sftp	- secure file transfer
rsync	- efficiently transfer and sync files across computers by checking timestamp and size
scp	- secure copy


WEB:
wget
curl

Advanced bash commands:

INTERACTION:
read <varname>  - requests input from the user and stores in varname


SHELL SCRIPTING:
#	- Used to add a comment, except when used as \#, or as #! when starting a script
\	- Used at the end of a line to indicate continuation on to the next line
;       - commands are executed sequentially, waiting for each to finish executing
&       - the shell runs the following cmd immediately in the background
&&      - executes the second command only if the first completes successfully
||      - executes the second command only if the first fails
$	- Indicates what follows is an environment variable
>	- redirect standard output (stout) to a file
>>	- append output to a file if it exists, or > if the file does not exist
<	- read from a file, formally known as redirect input
|	- Used to pipe the result into the next command
#!      - shebang used at the top to tell linux where to find the executable
exit    - used to set the return value; 0 for success, non-zero for failure
echo $? - used to check the return value after a program has run 

SCRIPT PARAMETERS (arguments):
$0		- Script name
$1		- First parameter
$2, $3, etc.	- Second, third parameter, etc.
$*		- All parameters
$#		- Number of arguments

COMMAND SUBSTITUTION:
No matter the method, the innermost command will be executed in a newly launched shell environment, and the standard output of the shell will be inserted where the command substitution was done.
`<cmd>` 
$(<cmd>) 
Both of these methods enable command substitution; however, the $( ) method allows command nesting. New scripts should always use of this more modern method.
ls /lib/modules/$(uname -r)/

VARIABLES:
environment variables: HOME, PATH, HOST, etc.
foo=bar		# no space!
echo $foo
>  bar
By default, the variables created within a script are local. To make them global (environment variables) use export:
export VAR=value
VAR=value ; export VAR
export with no arguments will give a list of all currently exported environment variables

FUNCTIONS:
    function_name () {
       command...
    }
The first argument can be referred to as $1, the second as $2, etc.
To call a function, treat it like a new command
# Functions (must be defined before use)
func1() {
echo " This message is from function 1"
}
func2() {
echo " This message is from function 2" 
}
echo "Enter a number, 1 or 2"
read n
func$n

FLOW CONTROL:
if TEST-COMMANDS; then CONSEQUENT-COMMANDS; fi
A more general definition is:
if [[ condition ]] 	# square brackets are used to delineate the test condition
then
       statements
elif [[ condition ]]
then
       statements
else
       statements
fi


file=$1
if [ -f file ]		# one set of square brackets will work but two is prefered
then
 echo -e "The $file exists"
else
 echo -e "The $file does not exist"
fi

CONDITION SYNTAX:
FILES:  if [[ -f file ]]
-e file	Checks if the file exists.
-d file	Checks if the file is a directory.
-f file	Checks if the file is a regular file (i.e., not a symbolic link, device node, directory, etc.)
-s file	Checks if the file is of non-zero size.
-g file	Checks if the file has sgid set.
-u file	Checks if the file has suid set.
-r file	Checks if the file is readable.
-w file	Checks if the file is writable.
-x file	Checks if the file is executable.
NUMERIC:  if [[ $first -eq 0 ]] && [[ $second -ne 0 ]]
-eq	Equal to
-ne	Not equal to
-gt	Greater than
-lt	Less than
-ge	Greater than or equal to
-le	Less than or equal to
BOOL: if [[ $first -eq 0 ]] && [[ $second -ne 0 ]]
&&	- AND	
||	- OR	
!	- NOT	
STRINGS: [ string1 == string2 ]
==	- EQUALS	

ARITHMETIC EXPRESSIONS:
Using the var=$((...)) syntax:
echo $((x+1))
Using the built-in shell command let:
let x=( 1 + 2 ); echo $x

EXAMPLES:

TEXT SEARCH/MANIPULATION
tr '{}' '()' < inputfile > outputfile		Translate braces into parenthesis
echo "This is for testing" | tr [:space:] '\t'	Translate white-space to tabs
echo "This   is a    test" | tr -s [:space:]    Squeeze repetition of characters using -s






